#+TITLE: emacs-lisp
#+DATE: <2016-11-02 Wed>
#+AUTHOR: Jezrael Arciaga
#+EMAIL: jezarciaga@gmail.com
#+OPTIONS: ':nil *:t -:t ::t <:t H:1 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t title:t toc:nil todo:t |:t
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.1.1 (Org mode 8.3.6)


* TODO [[https://www.gnu.org/software/emacs/manual/eintr.html][Introduction to emacs lisp]] [43%]
** DONE Why
   CLOSED: [2016-11-02 Wed 20:24]
** DONE On Reading this Text
   CLOSED: [2016-11-02 Wed 20:24]
** DONE Who You Are
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Lisp History
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Note for Novices
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Thank You
   CLOSED: [2016-11-02 Wed 20:25]
** DONE List Processing
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Lisp Lists
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Run a Program
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Making Errors
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Names & Definitions
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Lisp Interpreter
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Evaluation
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Variables
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Arguments
   CLOSED: [2016-11-02 Wed 20:25]
** DONE set & setq
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Summary
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Error Message Exercises
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Lisp Lists
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Numbers Lists
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Lisp Atoms
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Whitespace in Lists
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Typing Lists
   CLOSED: [2016-11-02 Wed 20:25]
** DONE The Lisp Interpreter
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Complications
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Byte Compiling
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Evaluation
   CLOSED: [2016-11-02 Wed 20:25]
** DONE How the Interpreter Acts
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Evaluating Inner Lists
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Variables
   CLOSED: [2016-11-02 Wed 20:25]
** DONE fill-column Example
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Void Function
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Void Variable
   CLOSED: [2016-11-02 Wed 20:25]
** DONE Arguments
   CLOSED: [2016-11-02 Wed 22:12]
** DONE Data types
   CLOSED: [2016-11-02 Wed 22:12]
** DONE Args as Variable or List
   CLOSED: [2016-11-02 Wed 22:12]
** DONE Variable Number of Arguments
   CLOSED: [2016-11-02 Wed 22:12]
** DONE Wrong Type of Argument
   CLOSED: [2016-11-02 Wed 22:12]
** DONE message
   CLOSED: [2016-11-02 Wed 22:23]
** DONE Setting the Value of a Variable
   CLOSED: [2016-11-02 Wed 22:23]
** DONE Using set
   CLOSED: [2016-11-02 Wed 22:23]
** DONE Using setq
   CLOSED: [2016-11-02 Wed 22:38]
** DONE Counting
   CLOSED: [2016-11-02 Wed 22:38]
** DONE Practicing Evaluation
   CLOSED: [2016-11-02 Wed 23:37]
** DONE How to Evaluate
   CLOSED: [2016-11-02 Wed 23:37]
** DONE Buffer Names
   CLOSED: [2016-11-03 Thu 08:07]
(insert (concat " ; " (buffer-name))) ; emacs-lisp.org
(insert (concat " ; " (buffer-file-name))) ; d:/workspace/learning/learning-emacs-lisp/emacs-lisp.org
** DONE Getting Buffers
   CLOSED: [2016-11-03 Thu 08:42]
** DONE Switching Buffers
   CLOSED: [2016-11-03 Thu 08:56]
** DONE Buffer Size & Locations
   CLOSED: [2016-11-03 Thu 09:03]
*** buffer-size
(buffer-size)
*** point
(point)
*** point-min
(point-min)
(point-max)
*** point-max
** DONE Evaluation Exercise
   CLOSED: [2016-11-03 Thu 09:03]
(insert (buffer-name))emacs-lisp.org
(insert
(buffer-file-name))d:/workspace/learning/learning-emacs-lisp/emacs-lisp.org
(insert (int-to-string (buffer-size)))11248
(insert (int-to-string (point-max)))11249
(insert (int-to-string (point)))3779
** DONE How To Write Function Definitions
   CLOSED: [2016-11-03 Thu 09:03]
** DONE Primitive Functions
   CLOSED: [2016-11-03 Thu 09:03]
** DONE defun
   CLOSED: [2016-11-06 Sun 02:00]
** DONE Install
   CLOSED: [2016-11-03 Thu 10:39]
#+BEGIN_SRC elisp
  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven"
    (interactive "p")
    (message "The result is %d" (* 7 number)))
#+END_SRC
** DONE Interactive
   CLOSED: [2016-11-06 Sun 02:00]
** DONE Interactive Options
   CLOSED: [2016-11-06 Sun 02:00]
** DONE Permanent Installation
   CLOSED: [2016-11-06 Sun 02:00]
** DONE let
   CLOSED: [2016-11-06 Sun 02:00]
** DONE if
   CLOSED: [2016-11-06 Sun 02:00]
** DONE else
   CLOSED: [2016-11-06 Sun 02:00]
** DONE Truth & Falsehood
   CLOSED: [2016-11-06 Sun 02:00]
** DONE save-excursion
   CLOSED: [2016-11-06 Sun 02:00]
** DONE Review
   CLOSED: [2016-11-06 Sun 02:03]
** DONE defun Exercises
   CLOSED: [2016-11-06 Sun 02:03]
** DONE Install a Function Definition
   CLOSED: [2016-11-06 Sun 02:03]
** DONE Effect of installation
   CLOSED: [2016-11-06 Sun 02:03]
** DONE Change a defun
   CLOSED: [2016-11-06 Sun 02:03]
** DONE Make a Function Interactive
   CLOSED: [2016-11-06 Sun 02:03]
** DONE Interactive multiply-by-seven
   CLOSED: [2016-11-06 Sun 02:03]
** DONE multiply-by-seven in detail
   CLOSED: [2016-11-06 Sun 02:03]
** DONE let
   CLOSED: [2016-11-06 Sun 02:03]
** DONE Prevent confusion
   CLOSED: [2016-11-06 Sun 02:04]
** DONE Parts of let Expression
   CLOSED: [2016-11-06 Sun 02:04]
** DONE Sample let Expression
   CLOSED: [2016-11-06 Sun 02:04]
** DONE Uninitialized let Variables
   CLOSED: [2016-11-06 Sun 02:04]
** DONE The if Special Form
   CLOSED: [2016-11-06 Sun 02:04]
** DONE if in more detail
   CLOSED: [2016-11-06 Sun 02:04]
** DONE type-of-animal in detail
   CLOSED: [2016-11-06 Sun 02:04]
** DONE Truth and Falsehood in Emacs Lisp
   CLOSED: [2016-11-06 Sun 02:04]
** DONE nil explained
   CLOSED: [2016-11-06 Sun 02:04]
** DONE save-excursion
   CLOSED: [2016-11-06 Sun 02:04]
** DONE Point and mark
   CLOSED: [2016-11-06 Sun 02:04]
** DONE Template for save-excursion
   CLOSED: [2016-11-06 Sun 02:04]
** DONE A Few Buffer-Related Functions
   CLOSED: [2016-11-06 Sun 02:04]
** DONE Finding More
   CLOSED: [2016-11-06 Sun 02:04]
** DONE simplified-beginning-of-buffer
   CLOSED: [2016-11-06 Sun 02:04]
** DONE mark-whole-buffer
   CLOSED: [2016-11-06 Sun 02:04]
** DONE [[https://www.gnu.org/software/emacs/manual/eintr.html#append_002dto_002dbuffer][append-to-buffer]]
   CLOSED: [2016-11-06 Sun 14:31]
#+BEGIN_SRC elisp
  (defun jez-append-to-buffer (buffer start end)
    "Append to specified BUFFER the test of the region
  specified by START and END"
    (interactive (list (read-buffer "Buffer name: " (other-buffer))
                       (region-beginning)
                       (region-end)))
    (let ((string-to-add (buffer-substring start end)))
      (save-excursion
        (get-buffer-create buffer)
        (insert string-to-add))))
#+END_SRC

#+RESULTS:
: jez-append-to-buffer

** DONE Buffer Related Review
   CLOSED: [2016-11-06 Sun 14:33]
** DONE Buffer Exercises
   CLOSED: [2016-11-13 Sun 21:58]
*** DONE Write your own =simplified-end-of-buffer= function definition; then test it to see wether it works
    CLOSED: [2016-11-10 Thu 22:42]

#+BEGIN_SRC elisp
  (defun simplified-end-of-buffer ()
    "Go to end of buffer"
    (goto-char (point-max)))
  (simplified-end-of-buffer)
#+END_SRC

#+RESULTS:
: simplified-end-of-buffer

*** DONE Use =if= and =get-buffer= to write a function that prints a message telling you whether a buffer exists
    CLOSED: [2016-11-13 Sun 21:33]

#+BEGIN_SRC elisp
  (defun jez/buffer-exists (buffer)
    "Prints in mini-buffer if `buffer` exists"
    (interactive
     (list (read-buffer "Input buffer name:"
                        (other-buffer (current-buffer)))))
    (let* ((buffer-names (mapcar 'buffer-name (buffer-list))))
      (if (member buffer buffer-names)
          (message (format "Buffer: %s exists" buffer))
        (message (format "Buffer: %s doesn't exists" buffer)))))
  (jez/buffer-exists "non-existing-buffer")
#+END_SRC

#+RESULTS:
: Buffer: non-existing-buffer doesn’t exists

(buffer-name (car (buffer-list)))
(member "test" (mapcar 'buffer-name (buffer-list)))
#+RESULTS:
: non existing buffer buffer exists


- [X] learn interactive mode
- [X] how it works
- [X] what are the codes like =p= =P=
- [X] read-buffer not working in interactive mode
- [X] append-to-buffer example seems to work using read-buffer

*** SKIP Using =find-tag=, find the source for the =copy-to-buffer= function.
**** [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Tags.html][Learn Tags]]

#+BEGIN_SRC elisp
  (find-tag "test")
#+END_SRC
** DONE The Definition of mark-whole-buffer
   CLOSED: [2016-11-13 Sun 23:38]
** DONE mark-whole-buffer overview
   CLOSED: [2016-11-13 Sun 23:38]
** DONE Body of mark-whole-buffer
   CLOSED: [2016-11-13 Sun 23:38]
** DONE The Definition of append-to-buffer
   CLOSED: [2016-11-13 Sun 23:38]
** DONE append-to-buffer overview
   CLOSED: [2016-11-13 Sun 23:39]
** DONE append interactive
   CLOSED: [2016-11-13 Sun 23:39]
** DONE append-to-buffer body
   CLOSED: [2016-11-13 Sun 23:39]
** DONE append save-excursion
   CLOSED: [2016-11-13 Sun 23:39]
** DONE A Few More Complex Functions
   CLOSED: [2016-11-13 Sun 23:39]
** DONE copy-to-buffer
   CLOSED: [2016-11-16 Wed 22:19]

#+BEGIN_SRC elisp
  (defun jez/copy-to-buffer (buffer)
    "Inserts selected region to BUFFER"
    (interactive "bInsert to buffer:")
    (let* ((string-to-copy (buffer-substring (region-beginning) (region-end))))
    (with-current-buffer buffer
      (insert (format "%s %s" string-to-copy string-to-copy)))))
#+END_SRC

#+RESULTS:
: jez/copy-to-buffer

** DONE insert-buffer
   CLOSED: [2016-11-18 Fri 00:46]

#+BEGIN_SRC elisp
      (defun jez/insert-buffer (buffer)
        "Insert after point the contents of another BUFFER.  Puts
  mark after the inserted text. BUFFER may be a buffer or a buffer
  name."
        (interactive "*bInsert buffer: ")
        (let (start
              end
              mark-new
              (buffer (or (bufferp buffer) (get-buffer buffer))))
          (save-excursion
            (save-excursion
              (set-buffer buffer)
              (setq start (point-min))
              (setq end (point-max)))
            (insert-buffer-substring buffer start end)
            (setq mark-new (point)))
          (push-mark mark-new)))
#+END_SRC

#+RESULTS:
: jez/insert-buffer

** DONE beginning-of-buffer
   CLOSED: [2016-11-19 Sat 19:48]

#+BEGIN_SRC elisp
  (defun jez/beginning-of-buffer (prefix)
    "Go to beginning of BUFFER"
    (interactive "P")
    (goto-char (point-min)))
#+END_SRC
#+RESULTS:
: jez/beginning-of-buffer

*** Optional Arguments

    To create optional argument use the =&optional= keyword.

**** Example

#+BEGIN_SRC elisp
  (defun jez/beginning-of-buffer (&optional arg)
    "docstring"
    (interactive "p")
    (goto-char (point-min))
    (cond ((stringp arg) (message (format "%s is a string" arg)))
          ((integerp arg) (message (format "%s is an integer" arg)))
          ((listp arg) (message (format "%s is a list" arg)))
          (t (message "default"))))
#+END_SRC

#+RESULTS:
: jez/beginning-of-buffer

***** "P" in the interactive expression

The "P" in the interactive expression tells Emacs to pass a prefix
argument, if there is one, to the function in raw form. A prefix
argument is made by typing the META key followed by a number, or by
typing C-u and then a number. (If you don’t type a number, C-u
defaults to a cons cell with a 4. A lowercase "p" in the interactive
expression causes the function to convert a prefix arg to a number.)

*** =beginning-of-buffer= with an Argument

#+BEGIN_SRC elisp
  (defun jez/beginning-of-buffer (&optional arg)
    "Go to beginning of current buffer"
    (interactive "P")
    (let* ((size (buffer-size))
          (point-target (if (< 1000 size)
                            ;; Avoid overflow for large buffer sizes!
                            (* (prefix-numeric-value arg) (/ size 10))
                          (/ (+ 10 (* size (prefix-numeric-value arg))) 10))))
      (message (format "going to %s" point-target))))
#+END_SRC

#+RESULTS:
: jez/beginning-of-buffer

** DONE Second Buffer Related Review
   CLOSED: [2016-11-20 Sun 10:02]


#+BEGIN_SRC elisp
  (defun jez/beginning-of-buffer (&optional arg)
    "This is a test"
    (interactive "P")
    (goto-char (point-min)))
#+END_SRC

#+RESULTS:
: jez/beginning-of-buffer

** DONE optional Exercise
   CLOSED: [2016-11-20 Sun 12:45]

#+BEGIN_SRC elisp
  (defun jez/compare-with-fill-column (number)
    "Compare NUMBER with FILL-COLUMN"
    (interactive "nNumber to check: ")
    (let (condition)
      (cond
       ((< number fill-column) (setq condition "less than"))
       ((= number fill-column) (setq condition "equal to"))
       (t (setq condition "greater than")))
      (message (format "%s is %s fill-column" number condition))))
#+END_SRC

#+RESULTS:
: jez/compare-with-fill-column

** DONE The Definition of insert-buffer
   CLOSED: [2016-11-20 Sun 12:52]
** DONE insert-buffer code
   CLOSED: [2016-11-20 Sun 12:52]
** DONE insert-buffer interactive
   CLOSED: [2016-11-20 Sun 12:52]
** DONE insert-buffer body
   CLOSED: [2016-11-20 Sun 12:52]
** DONE if & or
   CLOSED: [2016-11-20 Sun 12:56]

** DONE Insert or
   CLOSED: [2016-11-20 Sun 12:56]
** DONE Insert let
   CLOSED: [2016-11-20 Sun 12:56]
** DONE New insert-buffer
   CLOSED: [2016-11-20 Sun 12:57]
** DONE The Interactive Expression in insert-buffer
   CLOSED: [2016-11-20 Sun 12:57]
** DONE Read-only buffer
   CLOSED: [2016-11-20 Sun 12:57]
** DONE b for interactive
   CLOSED: [2016-11-20 Sun 12:57]
** DONE Complete Definition of beginning-of-buffer
   CLOSED: [2016-11-20 Sun 12:57]
** DONE Optional Arguments
   CLOSED: [2016-11-20 Sun 12:57]
** DONE beginning-of-buffer opt arg
   CLOSED: [2016-11-20 Sun 12:57]
** DONE beginning-of-buffer complete
   CLOSED: [2016-11-20 Sun 12:57]
** DONE beginning-of-buffer with an Argument
   CLOSED: [2016-11-20 Sun 12:57]
** DONE Disentangle beginning-of-buffer
   CLOSED: [2016-11-20 Sun 12:57]
** DONE Large buffer case
   CLOSED: [2016-11-20 Sun 20:35]

#+BEGIN_SRC elisp
  (defun jez/beginning-of-buffer (&optional prefix)
    "Move cursor to beginning of buffer"
    (interactive "p")
    (let* ((prefix (if prefix prefix 1))
           (size (- (point-max) (point-min)))
           (point-target (if (/= prefix 1)
                             (floor (* size (/ prefix 10.0)))
                           (point-min))))
      (goto-char point-target)))
#+END_SRC

#+RESULTS:
: jez/beginning-of-buffer

*** issue
**** I don't see a problem in large buffer
***** buffer size > 10000
***** read *What happens in a large buffer* (not worth it)
** DONE Small buffer case
   CLOSED: [2016-11-20 Sun 20:35]
** DONE Narrowing and Widening
   CLOSED: [2016-11-21 Mon 21:41]

*** =save-restriction= special form

#+BEGIN_SRC elisp
  (save-restriction
    (let* ((point-before (point-min))
           point-after)
      (widen)
      (setq point-after (point-min))
      (message "before: %s, after: %s" point-before point-after)))
#+END_SRC
#+RESULTS:
: before: 14911, after: 1

*** =what-line=

#+BEGIN_SRC elisp
  (defun jez/what-line ()
    "Print the current line number (in the buffer) of point."
    (interactive)
    (save-restriction
      (widen)
      (message "Line %d" (1+ (count-lines 1 (point))))))
#+END_SRC
#+RESULTS:
: jez/what-line

**** recent version of emacs =what-line= tells line number in *narrowed buffer* 

** DONE Narrowing advantages
   CLOSED: [2016-11-21 Mon 21:41]
** DONE save-restriction
   CLOSED: [2016-11-21 Mon 21:41]
** DONE what-line
   CLOSED: [2016-11-21 Mon 21:41]
** DONE narrow Exercise
   CLOSED: [2016-11-21 Mon 21:47]

*** Display the first 60 chars of current buffer, even narrowed buffer

*** use the following functions [66%]
    - [X] save-restriction
    - [X] widen
    - [ ] goto-char :: no need
    - [ ] point-min :: no need
    - [X] message
    - [X] buffer-substring

#+BEGIN_SRC elisp
  (defun jez/narrow-exercise ()
    "Display the first 60 chars of current buffer"
    (interactive)
    (save-restriction
      (widen)
      (message (buffer-substring 1 60))))
#+END_SRC
#+RESULTS:
: jez/narrow-exercise

** DONE car, cdr, cons: Fundamental Functions
   CLOSED: [2016-11-24 Thu 22:00]

#+BEGIN_SRC elisp
  (defun jez/beginning-of-buffer (&optional buffer-name)
    "Go to the beginning of buffer"
    (interactive "bBuffer Name: ")
    (message buffer-name))
#+END_SRC

#+RESULTS:
: jez/beginning-of-buffer


#+BEGIN_SRC elisp
  (defun jez/narrow-section ()
    "Custom function for learning emacs lisp"
    (interactive)
    (let ((start (save-excursion (search-backward-regexp "^[0-9]")))
          (end (save-excursion (search-forward-regexp "^[0-9]"))))
      (narrow-to-region start (- end 1))))
#+END_SRC

#+RESULTS:
: jez/narrow-section

** DONE Strange Names
   CLOSED: [2016-11-24 Thu 22:00]

** DONE car & cdr
   CLOSED: [2016-11-24 Thu 22:00]
** DONE cons
   CLOSED: [2016-11-24 Thu 22:00]
** DONE nthcdr
   CLOSED: [2016-11-24 Thu 22:00]
** DONE nth
   CLOSED: [2016-11-24 Thu 22:00]
** DONE setcar
   CLOSED: [2016-11-24 Thu 22:00]
** DONE setcdr
   CLOSED: [2016-11-24 Thu 22:00]
** DONE cons Exercise
   CLOSED: [2016-11-24 Thu 22:00]
** DONE cons
   CLOSED: [2016-11-24 Thu 22:00]
** DONE Build a list
   CLOSED: [2016-11-24 Thu 22:00]
** DONE length
   CLOSED: [2016-11-24 Thu 22:00]
** TODO Cutting and Storing Text
** TODO Storing Text
** TODO zap-to-char
** TODO kill-region
** TODO copy-region-as-kill
** TODO Digression into C
** TODO defvar
** TODO cons & search-fwd Review
** TODO search Exercises
** TODO zap-to-char
** TODO Complete zap-to-char
** TODO zap-to-char interactive
** TODO zap-to-char body
** TODO search-forward
** TODO progn
** TODO Summing up zap-to-char
** TODO kill-region
** TODO Complete kill-region
** TODO condition-case
** TODO Lisp macro
** TODO copy-region-as-kill
** TODO Complete copy-region-as-kill
** TODO copy-region-as-kill body
** TODO The Body of copy-region-as-kill
** TODO last-command & this-command
** TODO kill-append function
** TODO kill-new function
** TODO Initializing a Variable with defvar
** TODO See variable current value
** TODO defvar and asterisk
** TODO How Lists are Implemented
** TODO Lists diagrammed
** TODO Symbols as Chest
** TODO List Exercise
** TODO Yanking Text Back
** TODO Kill Ring Overview
** TODO kill-ring-yank-pointer
** TODO yank nthcdr Exercises
** TODO Loops and Recursion
** TODO while
** TODO dolist dotimes
** TODO Recursion
** TODO Looping exercise
** TODO while
** TODO Looping with while
** TODO Loop Example
** TODO print-elements-of-list
** TODO Incrementing Loop
** TODO Incrementing Loop Details
** TODO Decrementing Loop
** TODO Details of an Incrementing Loop
** TODO Incrementing Example
** TODO Inc Example parts
** TODO Inc Example altogether
** TODO Loop with a Decrementing Counter
** TODO Decrementing Example
** TODO Dec Example parts
** TODO Dec Example altogether
** TODO Save your time: dolist and dotimes
** TODO dolist
** TODO dotimes
** TODO Recursion
** TODO Building Robots
** TODO Recursive Definition Parts
** TODO Recursion with list
** TODO Recursive triangle function
** TODO Recursion with cond
** TODO Recursive Patterns
** TODO No Deferment
** TODO No deferment solution
** TODO Recursion in Place of a Counter
** TODO Recursive Example arg of 1 or 2
** TODO Recursive Example arg of 3 or 4
** TODO Recursive Patterns
** TODO Every
** TODO Accumulate
** TODO Keep
** TODO Regular Expression Searches
** TODO sentence-end
** TODO re-search-forward
** TODO forward-sentence
** TODO forward-paragraph
** TODO Regexp Review
** TODO re-search Exercises
** TODO forward-sentence
** TODO Complete forward-sentence
** TODO fwd-sentence while loops
** TODO fwd-sentence re-search
** TODO forward-paragraph: a Goldmine of Functions
** TODO forward-paragraph in brief
** TODO fwd-para let
** TODO fwd-para while
** TODO Counting: Repetition and Regexps
** TODO Why Count Words
** TODO count-words-example
** TODO recursive-count-words
** TODO Counting Exercise
** TODO The count-words-example Function
** TODO Design count-words-example
** TODO Whitespace Bug
** TODO Counting Words in a defun
** TODO Divide and Conquer
** TODO Words and Symbols
** TODO Syntax
** TODO count-words-in-defun
** TODO Several defuns
** TODO Find a File
** TODO lengths-list-file
** TODO Several files
** TODO Several files recursively
** TODO Prepare the data
** TODO Count Words in defuns in Different Files
** TODO lengths-list-many-files
** TODO append
** TODO Prepare the Data for Display in a Graph
** TODO Data for Display in Detail
** TODO Sorting
** TODO Files List
** TODO Counting function definitions
** TODO Readying a Graph
** TODO Columns of a graph
** TODO graph-body-print
** TODO recursive-graph-body-print
** TODO Printed Axes
** TODO Line Graph Exercise
** TODO Your .emacs File
** TODO Default Configuration
** TODO Site-wide Init
** TODO defcustom
** TODO Beginning init File
** TODO Text and Auto-fill
** TODO Mail Aliases
** TODO Indent Tabs Mode
** TODO Keybindings
** TODO Keymaps
** TODO Loading Files
** TODO Autoload
** TODO Simple Extension
** TODO X11 Colors
** TODO Miscellaneous
** TODO Mode Line
** TODO Debugging
** TODO debug
** TODO debug-on-entry
** TODO debug-on-quit
** TODO edebug
** TODO Debugging Exercises
** TODO Handling the Kill Ring
** TODO What the Kill Ring Does
** TODO current-kill
** TODO yank
** TODO yank-pop
** TODO ring file
** TODO The current-kill Function
** TODO Code for current-kill
** TODO Understanding current-kill
** TODO current-kill in Outline
** TODO Body of current-kill
** TODO Digression concerning error
** TODO Determining the Element
** TODO A Graph with Labeled Axes
** TODO Labeled Example
** TODO print-graph Varlist
** TODO print-Y-axis
** TODO print-X-axis
** TODO Print Whole Graph
** TODO The print-Y-axis Function
** TODO print-Y-axis in Detail
** TODO Height of label
** TODO Compute a Remainder
** TODO Y Axis Element
** TODO Y-axis-column
** TODO print-Y-axis Penultimate
** TODO The print-X-axis Function
** TODO Similarities differences
** TODO X Axis Tic Marks
** TODO Printing the Whole Graph
** TODO The final version
** TODO Test print-graph
** TODO Graphing words in defuns
** TODO lambda
** TODO mapcar
** TODO Another Bug
** TODO Final printed graph
** Reference
*** Helper function

#+NAME: jez/narrow-section
#+BEGIN_SRC elisp
  (defun jez/narrow-section ()
    "Custom function for learning emacs lisp"
    (interactive)
    (let ((start (save-excursion (search-backward-regexp "^[0-9]")))
          (end (save-excursion (search-forward-regexp "^[0-9]"))))
      (narrow-to-region start (- end 1))))
#+END_SRC
